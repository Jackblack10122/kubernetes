# -*- mode: ruby -*-
# vi: set ft=ruby :

require_relative "./utils"
require_relative "./hypervisor"
require_relative "./host"

# Define network that the virtual machines will join.
NETWORK_SETTINGS = {
  network_type: "NAT",              # NAT = use a private network; BRIDGE = use addresses from your broadband router's network.
  private_network: "192.168.56.",   # Network prefix for VM network if using NAT mode. Ignored for BRIDGE.
  ip_start: 11,                     # First IP to use for VMs on private network if using NAT mode. Ignored for BRIDGE.
}

# Get host details to be able to compute RAM/CPU for VMs according to resource availability.
# More RAM/CPU host has = beefier cluster!
h = Host.get()
if h.physical_ram_gb < 8
  raise "Insufficient memory #{h.physical_ram_gb} GB"
end
ram_selector = (h.physical_ram_gb / 4) * 4
cpu_count = h.cpu_count

# Define list of virtual machines to be created here.
VIRTUAL_MACHINES = [
  {
    name: "controlplane01",                     # Name (and hostname) for the VM
    cpu: h.cpu_count >= 12 ? 4 : 2,             # Number of vCPUs to assign it
    memory: [ram_selector * 128, 2048].max(),   # RAM in MB to assign it
    box: Hypervisor.ubuntu,                     # Operating system to run
    packages: [
      "tmux", "sshpass",
    ],
  },
  {
    name: "controlplane02",
    cpu: h.cpu_count > 8 ? 2 : 1,
    memory: [ram_selector * 128, 2048].min(),
    box: Hypervisor.ubuntu,       # Operating system to run
  },
  {
    name: "loadbalancer",
    cpu: h.cpu_count > 8 ? 2 : 1,
    memory: [ram_selector * 64, 1024].min(),
    box: Hypervisor.ubuntu,
  },
#   {
#     name: "node01",
#     cpu: (((h.cpu_count / 4) * 4) - 4) / 4,
#     memory: [ram_selector * 128, 4096].min(),
#     box: Hypervisor.ubuntu,
#   },
#   {
#     name: "node02",
#     cpu: (((h.cpu_count / 4) * 4) - 4) / 4,
#     memory: [ram_selector * 128, 4096].min(),
#     box: Hypervisor.ubuntu,
#   },
]

# Deploy the VMs
Vagrant.configure("2") do |config|
  config.vm.box_check_update = false

  # For each machine defined in VIRTUAL_MACHINES above
  VIRTUAL_MACHINES.each_with_index do |vm, index|
    config.vm.define vm[:name] do |node|
      # Set the "box", i.e. operating system for guest
      node.vm.box = vm[:box].box
      # Get hypervisor support for the host OS
      Hypervisor.get node: node do |hv|
        # Deploy the VM
        hv.deploy vm: vm, network: NETWORK_SETTINGS, index: index
      end
    end
  end

  # Tasks to perform before any VMs are created
  config_shown = false
  config.trigger.before :up do |trigger|
    trigger.info = "Pre-start trigger"
    trigger.ruby do |env, machine|
      if !config_shown
        host = Host.get()
        show_system_info(trigger, host)
        VIRTUAL_MACHINES.each do |vm|
          puts "--> #{vm[:name]} - CPU: #{vm[:cpu]}, RAM #{vm[:memory]}"
        end
        validate_configuration(trigger, host, VIRTUAL_MACHINES)
        config_shown = true
      end
    end
  end

  # Tasks to perform after all VMs are created
  vm_count = 0
  config.trigger.after :up do |trigger|
    trigger.info = "Post-provision"
    trigger.ruby do |env, machine|
      vm_count += 1
      if vm_count == env.machine_names.length()
        post_provision(env)
      end
    end
  end
end
